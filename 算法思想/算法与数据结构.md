> 算法和数据结构记得在学校的时候，老师说特别重要，当时也没有特别在意。但在找工作的时候慢慢意识到了他的重要性，现在后悔也晚了，为了之后的面试我只能把它慢慢抓起来，即使它很单调乏味，也是我们程序员道路上必须经历的门槛。

# 基本概念

## 一、算法和数据结构的关系

- 算法：如何处理数据
- 数据结构：数据之间的关系
- 关系：数据结构是算法的基础

## 二、逻辑结构和存储结构

- 逻辑结构：树、图、栈、队列、数组、链表、广义表
- 存储(物理)结构：索引、数组、链表、散列

## 三、经典算法题

- 字符串匹配
- 马踏棋盘
- 八皇后问题
- 汉诺塔问题
- 棋盘压缩
- 单链表实现
- 约瑟夫问题

## 四、时间复杂度

1. 事前估计：通过时间复杂度
   - 计算方法
     - 忽略低次幂
     - 忽略常数
     - 忽略系数
   - 常见时间复杂度
     - 1
     - ㏒₂n
     - n
     - nlog₂n
     - n^2
     - n^3
     - n^k
     - 2^n
2. 事后统计：需要在同一个计算机上，确保硬件条件保持一致

# 常见的数据结构

## 线性

> 主要是一对一的关系，能够连成一条串的那种。

### 一、数组

#### 1.稀疏数组

> 通常用于保存数组中很多为0的情况，能大幅度压缩空间的大小。
>
> 基本思路:
>
> 1. 用一个二维数组保存，第一行为他的行数，列数，以及有效数据的个数。
> 2. 其他行保存数据的行、列以及实际的数据。
> 3. 还原只需要遍历这个压缩数组即可。

```java
// 普通数组转换为稀疏数组
public int[][] toLess(int[][] arr) {    
int count = count(arr);    // 稀疏数组    
int[][] less = new int[count+1][3];    
less[0][0] = arr.length;    
less[0][1] = arr[0].length;    
less[0][2] = count;    
int index = 0;    
for(int i=0;i<arr.length;i++) 
{        
    for(int j=0;j<arr[i].length;j++) {            
        if(arr[i][j] != 0) {                
            index++;                
            less[index][0] = i;                
            less[index][1] = j;                
            less[index][2] = arr[i][j];            
        }        
    }    
}    
    return less;
}

// 稀疏数组转换为普通数组
public int[][] toMore(int[][] arr) {    
    int[][] more = new int[arr[0][0]][arr[0][1]];    
    for(int i=1;i<arr.length;i++) {        
        more[arr[i][0]][arr[i][1]] = arr[i][2];    
    }    
    return more;
}

//遍历二维数组
public int[][] display(int[] arr) {    
    for(int i=0;i<arr.length;i++) {        
        for (int j = 0; j < arr[i].length; j++) {            
            System.out.print(arr[i][j]+" ");       
        }        
        System.out.println();    
    }
}

// 获得二维数组非零个数
public static int count(int[][] arr) {    
    int sum = 0;    
    for(int i=0;i<arr.length;i++) {        
        for(int j=0;j<arr[i].length;j++) {            
            if(arr[i][j] != 0) {                
                sum++;            
            }        
        }    
    }    
    return sum;
}
```

### 二、链表

#### 1. 单向链表

- 普通链表

  > 基本思路：
  >
  > 1. 需要一个单向节点，主要保存数据和下一个节点的地址
  > 2. 单链表有有一个头指针，只是单纯的指向头节点，有利于后续的操作

  ```java
  public class MyLinkedList {
      private Node head = new Node(); // 单纯的空
      private Node rear;
  
      public void add(int num) {
          Node node = new Node(num, null);
          Node temp = head;
          while (temp.next != null) {
              temp = temp.next;
          }
          temp.next = node;
      }
  
      /**
       * 通过另一只链表使其反转，遍历当前链表，将链表依次添加到新链表的头个元素
       */
      public void reverse() {
          if(head.next == null || head.next.next == null) {
              return;
          }
          Node temp = head;
          Node nodeHead = new Node();
          Node cur = head.next;
          Node next = null;
          while(cur != null) {
              next = cur.next;
              cur.next = nodeHead.next;
              nodeHead.next = cur;
              cur = next;
          }
          head.next = nodeHead.next;
      }
  
      /**
       * 倒叙打印，遍历链表，添加到栈内，然后取出打印
       */
      public void reverseDisplay() {
          Stack<Node> stack = new Stack<>();
          Node temp = head;
          while(temp.next != null) {
              stack.push(temp.next);
              temp = temp.next;
          }
  
          while(!stack.isEmpty()) {
              System.out.println(stack.pop().value);
          }
      }
  
      public void addByOrder(int num) {
          Node node = new Node(num, null);
          Node temp = head;
          boolean flag = false;
          while(temp.next != null && temp.next.value < num) {
              if(temp.next.value == num) {
                  flag = true;
                  break;
              }
              temp = temp.next;
          }
  
          if(flag) {
              System.out.println("存在"+num+",不能添加");
          }else {
              node.next = temp.next;
              temp.next = node;
          }
      }
  
      /**
       * 链表倒数索引值
       * @param index
       * @return
       */
      public int getLastIndex(int index) {
          if(index <= 0 || index > size()) {
              throw new RuntimeException("不存在此元素");
          }
          Node temp = head;
          int limit = size() - index+1;
          for (int i = 0; i < limit; i++) {
              temp = temp.next;
          }
          return temp.value;
      }
  
      /**
       * 链表值的数量
       * @return
       */
      public int size() {
          Node temp = head;
          int size = 0;
          while(temp.next != null) {
              size++;
              temp = temp.next;
          }
          return size;
      }
  
      public void delete(int num) {
          // 需要指向删除节点的前一个节点
          Node temp = head;
          boolean flag = false;
          while(temp.next != null) {
              if(temp.next.value == num) {
                  temp.next = temp.next.next;
                  flag = true;
                  break;
              }
              temp = temp.next;
          }
  
          if(!flag) {
              System.out.println("没有找到"+num);
          }
      }
  
      public void show() {
          if(head.next == null) {
              System.out.println("[]");
              return;
          }
          Node temp = head;
          while(temp.next != null) {
              System.out.println(temp.next.value);
              temp = temp.next;
          }
      }
  
      private class Node {
          private Node next;
          private int value;
  
          public Node(int value, Node node) {
              this.value = value;
              this.next = node;
          }
  
          public Node() {}
      }
  }
  ```

- 约瑟夫环

  ``` java
  public class CircleLinkedList {
      private Node first;
      private int size;
  
      /**
       * 添加的数量
       * @param num
       */
      public void add(int num) {
          if(num < 1) {
              System.out.println("数量不对");
          }
          Node cur = null;
          for (int i = 1; i <= num; i++) {
              Node node = new Node(i, null);
              // 添加元素为1的情况
              if(i == 1) {
                  first = node;
                  node.next = node;
                  cur = node;
              // 添加多个元素
              }else {
                  cur.next = node;
                  node.next = first;
                  cur = node;
              }
              size++;
          }
      }
  
      public void show() {
          Node temp = first;
          while(true) {
              System.out.println(temp.value);
              if(temp.next == first) {
                  break;
              }
              temp=temp.next;
          }
      }
  
      /**
       * @param start 开始
       * @param countNum 每次数的个数
       */
      public void count(int start, int countNum) {
         if(start < 1 || start > size || first == null) {
             System.out.println("输入有误");
         }
  
         // 初始化辅助节点，指向first后面的节点
         Node helper = first;
         while(helper.next != first) {
             helper = helper.next;
         }
  
         // 移动节点到初始化位置
          for (int i = 0; i < start - 1; i++) {
              first = first.next;
              helper = helper.next;
          }
          
          // 开始数，一次取出
          while(helper != first) {
              for (int i = 0; i < countNum-1; i++) {
                  helper = helper.next;
                  first = first.next;
              }
              System.out.println(first.value);
              first = first.next;
              helper.next = first;
          }
          System.out.println(helper.value);
      }
  
      public static void main(String[] args) {
          CircleLinkedList circleLinkedList = new CircleLinkedList();
          circleLinkedList.add(5);
          circleLinkedList.show();
          System.out.println("------------------");
          System.out.println(circleLinkedList.size);
          System.out.println("------------------");
          circleLinkedList.count(1, 3);
      }
  
      private class Node {
          private int value;
          private Node next;
  
          public Node(int value, Node node) {
              this.value = value;
              this.next = node;
          }
  
          public Node() {}
      }
  }
  ```

#### 2. 双向链表

> 双向链表比起单向链表具有更好的灵活性，能够更好进行查询，相当于用空间换效率。

- python

  ``` python
  class Node:
      def __init__(self, data):
          self.preNode = None
          self.nextNode = None
          self.data = data
  
      def __str__(self):
          return "{%s}" % self.data
  
      def __repr__(self):
          return "{%s}" % self.data
  
  
  class DoubleLinkedList:
      def __init__(self, capacity=0xffff):
          self.head = None
          self.tail = None
          self.capacity = capacity
          self.size = 0
  
      def __add_head(self, node):
          if not self.head:
              self.head = node
              self.tail = node
              self.head.preNode = None
              self.head.nextNode = None
          else:
              node.nextNode = self.head
              self.head.preNode = node
              self.head = node
              self.head.preNode = None
          self.size += 1
          return node
  
      def __add_tail(self, node):
          if not self.tail:
              self.head = node
              self.tail = node
              self.tail.preNode = None
              self.tail.nextNode = None
          else:
              self.tail.nextNode = node
              node.preNode = self.tail
              self.tail = node
              self.tail.nextNode = None
          self.size += 1
          return node
  
      def __delete_head(self):
          if not self.head:
              return
          head = self.head
          if self.head.nextNode:
              self.head = head.nextNode
              self.head.preNode = None
          else:
              self.head = self.tail = None
          self.size -= 1
          return head
  
      def __delete_tail(self):
          if not self.tail:
              return
          tail = self.tail
          if tail.preNode:
              self.tail = tail.preNode
              self.tail.nextNode = None
          else:
              self.tail = self.head = None
          self.size -= 1
          return tail
  
      def __remove(self, node):
          if not node:
              node = self.tail
          if node == self.tail:
              self.__delete_tail()
          elif node == self.head:
              self.__delete_head()
          else:
              node.preNode.nextNode = node.nextNode
              node.nextNode.preNode = node.preNode
              self.size -= 1
          return node
  
      def pop(self):
          return self.__delete_head()
  
      def append(self, node):
          return self.__add_tail(node)
  
      def append_head(self, node):
          return self.__add_head(node)
  
      def remove(self, node=None):
          return self.__remove(node)
  
      def print(self):
          head = self.head
          while head:
              print(head, end="")
              head = head.nextNode
              if head:
                  print("=>", end="")
          print("")
  
      def ifExist(self, value):
          head = self.head
          node = None
          while head:
              if head.data == value:
                  node = head
                  break
              head = head.nextNode
          return node
  
  
  if __name__ == "__main__":
      my_list = DoubleLinkedList()
      # 尾部添加
      for i in range(10):
          node = Node(i)
          my_list.append(node)
      # 头部添加
      my_list.append_head(Node(11))
      my_list.print()
      print(my_list.size)
      # 头部删除
      my_list.pop()
      my_list.print()
      print(my_list.size)
      # 尾部删除
      my_list.remove()
      my_list.print()
      print(my_list.size)
      print(my_list.ifExist(5))
  ```

- java

  > 双向链表和单向链表不同的是需要维护两个指针，前驱和后继。
  
  ```java
  public class MyDoubleLinkedList {
      private Node head = new Node(); // 单纯的空
      private Node rear = new Node();
  
      public void add(int num) {
          Node node = new Node(num, null, null);
          Node temp = head;
          if(head.next == null) {
              head.next = node;
              return;
          }
  
          while (temp.next != null) {
              temp = temp.next;
          }
          temp.next = node;
          node.pre = temp;
          rear.pre = node;
      }
      
      /**
       * 倒叙打印
       */
      public void reverseDisplay() {
          Node temp = rear;
          while(temp.pre != null) {
              System.out.println(temp.pre.value);
              temp = temp.pre;
          }
      }
  
      /**
       * 链表倒数索引值
       * @param index
       * @return
       */
      public int getLastIndex(int index) {
          Node temp = rear;
          for (int i = 0; i < index-1; i++) {
              temp = temp.pre;
          }
          return temp.pre.value;
      }
  
      /**
       * 链表值的数量
       * @return
       */
      public int size() {
          Node temp = head;
          int size = 0;
          while(temp.next != null) {
              size++;
              temp = temp.next;
          }
          return size;
      }
  
      public void delete(int num) {
          Node cur = head.next;
          boolean flag = false;
          while(cur != null) {
              if(cur.value == num) {
                  cur.pre.next = cur.next;
                  // 但可能是最后一个节点，存在空指针问题
                  if(cur.next != null) {
                      cur.next.pre = cur.pre;
                  }else {
                      rear.pre = cur.pre;
                  }
                  flag = true;
                  break;
              }
              cur = cur.next;
          }
  
          if(!flag) {
              System.out.println("没有找到"+num);
          }
      }
  
      public void show() {
          if(head.next == null) {
              System.out.println("[]");
              return;
          }
          Node temp = head;
          while(temp.next != null) {
              System.out.println(temp.next.value);
              temp = temp.next;
          }
      }
  
      public static void main(String[] args) {
          MyDoubleLinkedList myDoubleLinkedList = new MyDoubleLinkedList();
          myDoubleLinkedList.add(33);
          myDoubleLinkedList.add(44);
          myDoubleLinkedList.add(55);
          myDoubleLinkedList.add(22);
          myDoubleLinkedList.delete(11);
          System.out.println(myDoubleLinkedList.rear.pre.value);
          System.out.println("-----------------");
          myDoubleLinkedList.show();
          System.out.println("-----------------");
          myDoubleLinkedList.reverseDisplay();
          System.out.println("-----------------");
          System.out.println(myDoubleLinkedList.getLastIndex(1));
          System.out.println("-----------------");
          myDoubleLinkedList.reverse();
          myDoubleLinkedList.show();
      }
  
      private class Node {
          private Node next;
          private Node pre;
          private int value;
  
          public Node(int value, Node node, Node pre) {
              this.value = value;
              this.next = node;
              this.pre = pre;
          }
  
          public Node() {}
      }
  }
  ```

### 三、栈

> 栈的特性是先进后出，这个特性在做某些操作时十分有用，比如返回上一个界面、子程序调用、处理递归、表达式转换、二叉树遍历和图的深度优先等。

- 普通栈

  ``` java
  public class ArrayStack {
      public static void main(String[] args) {
          ArrayStack arrayStack = new ArrayStack(4);
          arrayStack.push(3);
          arrayStack.push(7);
          arrayStack.push(5);
          arrayStack.push(22);
          arrayStack.show();
          System.out.println("-------------------");
          System.out.println(arrayStack.pop());
          System.out.println(arrayStack.pop());
      }
  
      private int maxSize;
      private int[] arr;
      private int top = -1;
  
      public ArrayStack(int size) {
          this.maxSize = size;
          arr = new int[size];
      }
  
      public void show() {
          for (int i = top; i >= 0; i--) {
              System.out.print(arr[i]+" ");
          }
      }
  
      public void push(int value) {
          if (isFull()) {
              throw new RuntimeException("栈已满");
          }
          top ++;
          arr[top]  = value;
      }
  
      public int pop() {
          if(isEmpty()) {
              throw new RuntimeException("栈为空");
          }
          int value = arr[top];
          top --;
          return value;
      }
  
      public boolean isEmpty() {
          return top == -1;
      }
  
      public boolean isFull() {
          return top == maxSize - 1;
      }
  }
  ```

- 使用栈实现综合计算器(不带括号)

  ``` java
  public class ArrayStack {
      public static void main(String[] args) {
          String str = "100*5+2+1";
          ArrayStack operStack = new ArrayStack(10);
          ArrayStack numStack = new ArrayStack(10);
          int index = 0;
          int num1 = 0;
          int num2 = 0;
          int oper = 0;
          int res = 0;
          char ch = 0;
          String moreNum = "";
          while(index < str.length()) {
              ch = str.charAt(index);
              if(isOper(ch)) {
                  if(operStack.isEmpty()) {
                      operStack.push(ch);
                  }else {
                      if(priority(operStack.peek()) > priority(ch)) {
                          oper = operStack.pop();
                          num1 = numStack.pop();
                          num2 = numStack.pop();
                          res = cal(num1, num2, (char) oper);
                          numStack.push(res);
  
                      }
                      operStack.push(ch);
                  }
              }else {
                  moreNum += ch;
                  if(index == str.length() - 1) {
                      numStack.push(Integer.parseInt(moreNum));
                      break;
                  }
  
                  if(isOper(str.charAt(index+1))) {
                      numStack.push(Integer.parseInt(moreNum));
                      moreNum = "";
                  }
              }
              index ++;
          }
  
          while(!operStack.isEmpty()) {
              oper = operStack.pop();
              num1 = numStack.pop();
              num2 = numStack.pop();
              int cal = numStack.cal(num1, num2, (char) oper);
              numStack.push(cal);
          }
          System.out.println(numStack.pop());
      }
  
      private int maxSize;
      private int[] arr;
      private int top = -1;
  
      public ArrayStack(int size) {
          this.maxSize = size;
          arr = new int[size];
      }
  
      public int peek() {
          return arr[top];
      }
  
      public void show() {
          for (int i = top; i >= 0; i--) {
              System.out.print(arr[i]+" ");
          }
      }
  
      public void push(int value) {
          if (isFull()) {
              throw new RuntimeException("栈已满");
          }
          top ++;
          arr[top]  = value;
      }
  
      public int pop() {
          if(isEmpty()) {
              throw new RuntimeException("栈为空");
          }
          int value = arr[top];
          top --;
          return value;
      }
  
      public boolean isEmpty() {
          return top == -1;
      }
  
      public boolean isFull() {
          return top == maxSize - 1;
      }
  
      public static int priority(int oper) {
          if(oper == '/' || oper == '*') {
              return 1;
          }else if(oper == '+' || oper == '-') {
              return 0;
          }else {
              return -1;
          }
      }
  
      public static boolean isOper(char oper) {
        return oper == '+' || oper == '-' || oper == '*' || oper == '/';
      }
  
      public static int cal(int num1, int num2, char oper) {
          int result = 0;
          switch(oper) {
              case '+':
                  result = num1 + num2;
                  break;
              case '-':
                  result = num2 - num1;
                  break;
              case '*':
                  result = num2 * num1;
                  break;
              case '/':
                  result = num2/num1;
                  break;
          }
          return result;
      }
  }
  ```
  
- 综合计算器(带括号，需要将中缀表达式转换为后缀表达式)

  ``` java
  public class CalTest {
      public static void main(String[] args) {
          String str = "1+((2+3)*4)-5";
          List<String> strings = toSuffixExpressionList(toInfixExpressionList(str));
          int i = calSuffixExpression(strings);
          System.out.println(i);
      }
  
      /**
      * 计算后缀表达式，依次取出元素，如果是数字就压入栈，是运算符就从栈中取出数字再重新压入，最后栈中剩下的数字就是计算的结果。
      */
      public static int calSuffixExpression(List<String> suffixExpression) {
          Stack<String> stack = new Stack<>();
          for (String s : suffixExpression) {
              if(s.matches("\\d+")) {
                  stack.push(s);
              }else {
                  int num1 = Integer.parseInt(stack.pop());
                  int num2 = Integer.parseInt(stack.pop());
                  int cal = cal(num1, num2, s.charAt(0));
                  stack.push(""+cal);
              }
          }
          return Integer.parseInt(stack.pop());
      }
  
      /**
       * 将中缀表达式转换为后缀表达式
       * @param list 中缀表达式集合
       * @return
       */
      public static List<String> toSuffixExpressionList(List<String> elems) {
          // 需要一个栈和一个集合
          Stack<String> stack = new Stack<>();
          List<String> list = new ArrayList<>();
  
          for (String ele : elems) {
              // 是数字直接加入集合
              if(ele.matches("\\d+")) {
                  list.add(ele);
              // 左括号直接加入栈
              }else if(ele.equals("(")) {
                  stack.push(ele);
              }else if(ele.equals(")")) {
                  // 与到右括号把栈中元素弹出添加到集合中，直到与到左括号，
                  while(!stack.peek().equals("(")) {
                      list.add(stack.pop());
                  }
                  // 去除左括号
                  stack.pop();
              }else {
                  // 如果是运算符，比较优先级，比栈中优先级低的话，就先把栈中元素弹出到集合，再压栈
                  while(stack.size() != 0 && getPriority(ele) <= getPriority(stack.peek())) {
                      list.add(stack.pop());
                  }
                  stack.push(ele);
              }
          }
  
          // 最后将栈中元素依次弹出到集合
          while(!stack.isEmpty()) {
              list.add(stack.pop());
          }
          return list;
      }
  
      /**
       * 将字符串转换为集合，主要涉及到
       * @return
       */
      public static List<String> toInfixExpressionList(String str) {
          int index = 0;
          char ch = 0;
          List<String> list = new ArrayList<>();
          String moreNum = "";
          while(index < str.length()) {
              ch = str.charAt(index);
              // 如果是运算符直接添加
              if(ch > 57 || ch < 48) {
                  list.add(""+ch);
              }else {
                  moreNum += ch;
                  // 最后一个字符时直接添加
                  if(index == str.length() - 1) {
                      list.add(moreNum);
                      break;
                  }
  
                  // 判断下一个是否为运算符，如果是就需要将之前拼接的数字添加到集合，同时置空
                  char c = str.charAt(index + 1);
                  if(c < 48 || c > 57) {
                      list.add(moreNum);
                      moreNum = "";
                  }
              }
              index ++;
          }
          return list;
      }
  
      /**
      * 判断运算符的优先级
      */
      public static int getPriority(String oper) {
          int result = 0;
          if(oper.equals("/") || oper.equals("*")) {
              result = 2;
          }else if(oper.equals("+") || oper.equals("-")) {
              result = 1;
          }
          return result;
      }
  
      /**
     	* 对出栈元素进行运算,后出栈的通常为被减数和被除数
     	*/
      public static int cal(int num1, int num2, char oper) {
          int result = 0;
          switch(oper) {
              case '+':
                  result = num1 + num2;
                  break;
              case '-':
                  result = num2 - num1;
                  break;
              case '*':
                  result = num2 * num1;
                  break;
              case '/':
                  result = num2/num1;
                  break;
          }
          return result;
      }
  }
  ```

- 表达式的运用

  - 前缀(波兰表达式)
  - 中缀：人们常见的表达式
  - 后缀(逆波兰表达式，计算机常用的表达式

### 四、队列

> 队列的特性就是先进先出，很多算法通过队列能够简化一些代码，还是很值得学习的。循环队列能够很好的利用数组的空间，难点就是头尾下标的移动以及数量的计算。

```java
// 满的情况
(rear+1)%maxsize = front
// 元素个数
(rear+maxsize-front)%maxsize

public class MyQueue {
    private int front;
    private int rear;
    private int[] arr;
    private int maxSize;
    private int realMaxSize;

    public int getRealSize() {
        return realMaxSize;
    }

    public int getNum() {
        return (rear+maxSize-front)%maxSize;
    }

    public MyQueue(int realSize) {
        this.arr = new int[realSize+1];
        this.maxSize = realSize+1;
        this.realMaxSize = realSize;
    }

    public int get() {
        if (ifEmpty()) {
            throw new RuntimeException("队列已空");
        }
        int temp = arr[front];
        front = (front+1) % maxSize;
        return temp;
    }

    public int peek() {
        if (ifEmpty()) {
            throw new RuntimeException("队列已空");
        }
        return arr[front];
    }

    public void add(int num) {
        if(ifFull()) {
            throw new RuntimeException("队列已满");
        }
        arr[rear] = num;
        rear = (rear+1)%maxSize;
    }

    public boolean ifEmpty() {
        return rear == front;
    }

    public boolean ifFull() {
        return (rear+1)%maxSize == front;
    }

    public void show() {
        if(ifEmpty()) {
            System.out.println("[]");
        }else {
            for (int i = front; i <= getNum()+front; i++) {
                System.out.print(this.arr[i%maxSize]+" ");
            }
        }
    }

    public static void main(String[] args) {
        MyQueue myQueue = new MyQueue(4);
        myQueue.add(3);
        myQueue.add(4); 
        myQueue.add(5);
        myQueue.add(6);
//        myQueue.add(3);
        System.out.println(myQueue.get());
        myQueue.add(8);
        myQueue.show();
    }
}
```

## 非线性

> 不是一对一的关系，可能存在多对多或一对多，甚至是散列的形式。

### 一、树

> 不但拥有比较快的查询速度，同时也能够快速修改、删除。常见的有b树、红黑树、堆、伸展树。

#### 1. 基础部分

##### 1.1. 常用术语

- 根节点：最上面的
- 叶子节点：度为0点
- 节点的权：节点的值
- 路径
- 度：下面的子节点的个数，树的度为度的最大值
- 层
- 子树
- 树的高度
- 森林
- 空树：没有节点的树
- 节点关系
  - 父节点
  - 子节点
  - 兄弟节点

##### 1.2. 相关定义

- 子树不能相交
- 不能存在多个根节点

##### 1.3. 叉树的相关概念

> 二叉树表示每个节点最多只能有两个子节点。

- 满二叉树

  > 最后一层满叶子节点。

  - 总节点数2^n-1

- 完全二叉树

  > 最后一层左边连续，倒数第二层右边连续。

##### 1.4. 遍历顺序

- 遍历：根节点的位置
  - 前序：根左右

    > 先输出父节点，再遍历左子树和右子中序

  - 中序：左根右

    > 先左节点，再父节点和有节点

  - 后序：左右根
  
    > 先左右节点，后父节点

#### 2. 应用部分

### 2.1. 表示方法

- 双亲表示法
  - parent
  - data

##### 一、链式存储

``` java
public class Demo {
    public static void main(String[] args) {
        TreeNode root = new TreeNode(1, "小明");
        TreeNode one = new TreeNode(5, "小李");
        TreeNode two = new TreeNode(7, "小王");
        TreeNode three = new TreeNode(3, "小张");
        TreeNode four = new TreeNode(6, "小绿");
        root.setLeft(one);
        root.setRight(two);
        two.setRight(three);
        two.setLeft(four);

        Tree tree = new Tree(root);
        System.out.println("================前序");
        tree.preDisplay();
        System.out.println("================中序");
        tree.midDisplay();
        System.out.println("================后序");
        tree.suffixDisplay();
        System.out.println("================查找");
        Integer num = 3;
        System.out.println(tree.findMid(num));
        System.out.println(tree.findSuffix(num));
        System.out.println(tree.findPre(num));
    }
}

class Tree {
    private TreeNode root;

    public Tree(TreeNode treeNode) {
        this.root = treeNode;
    }

    public String findPre(Integer id) {
        if(root == null) {
            throw  new RuntimeException("树为空");
        }else {
            return findpre(root, id);
        }
    }

    public String findMid(Integer id) {
        if(root == null) {
            throw  new RuntimeException("树为空");
        }else {
            return findmid(root, id);
        }
    }

    public String findSuffix(Integer id) {
        if(root == null) {
            throw  new RuntimeException("树为空");
        }else {
            return findsuffix(root, id);
        }
    }

    private String findpre(TreeNode treeNode, Integer id) {
        if(treeNode.getId() == id) {
            return treeNode.getName();
        }
        String result = null;
        if(treeNode.getLeft() != null) {
            result = findpre(treeNode.getLeft(), id);
        }
        if(result != null) {
            return result;
        }
        if(treeNode.getRight() != null) {
            result = findpre(treeNode.getRight(), id);
        }
        return result;
    }

    private String findmid(TreeNode treeNode, Integer id) {
        String result = null;
        if(treeNode.getLeft() != null) {
            result = findmid(treeNode.getLeft(), id);
        }
        if(result != null) {
            return result;
        }
        if(treeNode.getId() == id) {
            return treeNode.getName();
        }
        if(treeNode.getRight() != null) {
           result = findmid(treeNode.getRight(), id);
        }
        return result;
    }

    private String findsuffix(TreeNode treeNode, Integer id) {
        String result = null;
        if(treeNode.getLeft() != null) {
            result = findsuffix(treeNode.getLeft(), id);
        }
        if(result != null) {
            return result;
        }
        if(treeNode.getRight() != null) {
            result = findsuffix(treeNode.getRight(), id);
        }
        if(result != null) {
            return result;
        }
        if(treeNode.getId() == id) {
            result = treeNode.getName();
        }
        return result;
    }

    public void preDisplay() {
        if(root == null) {
            System.out.println("树为空");
        }else {
            predisplay(root);
        }
    }


    private void predisplay(TreeNode treeNode) {
        System.out.println(treeNode);
        if(treeNode.getLeft()!=null) {
            predisplay(treeNode.getLeft());
        }
        if(treeNode.getRight()!=null) {
            predisplay(treeNode.getRight());
        }
    }

    private void suffixdisplay(TreeNode treeNode) {
        if(treeNode.getLeft()!=null) {
            suffixdisplay(treeNode.getLeft());
        }
        if(treeNode.getRight()!=null) {
            suffixdisplay(treeNode.getRight());
        }
        System.out.println(treeNode);
    }

    private void middisplay(TreeNode treeNode) {
        if(treeNode.getLeft()!=null) {
            middisplay(treeNode.getLeft());
        }
        System.out.println(treeNode);
        if(treeNode.getRight()!=null) {
            middisplay(treeNode.getRight());
        }
    }

    public void midDisplay() {
        if(root == null) {
            System.out.println("树为空");
        }else {
            middisplay(root);
        }
    }

    public void suffixDisplay() {
        if(root == null) {
            System.out.println("树为空");
        }else {
            suffixdisplay(root);
        }
    }
}

@Data
class TreeNode {
    private Integer id;
    private String name;
    private TreeNode left;
    private TreeNode right;

    public TreeNode(Integer id)  {
        this.id = id;
    }

    public TreeNode(Integer id, String name)  {
        this.id = id;
        this.name = name;
    }

    public String toString() {
        return this.id+" "+this.name;
    }
}
```

##### 二、顺序存储(一般为完全二叉树)

``` java
/**
* 第n个元素的左子节点为2*n+1
* 第n个元素的柚子节点为2*n+2
* 第n个元素的父节点为(n-1)/2
*/
public class ArrBinaryTree {
    private int[] arr;

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
        arrBinaryTree.preDisplay();
        System.out.println("======================");
        arrBinaryTree.infixDisplay();
        System.out.println("======================");
        arrBinaryTree.sufDisplay();
    }

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }

    public void preDisplay() {
        prefixOrder(0);
    }

    public void infixDisplay() {
        infixOrder(0);
    }

    public void sufDisplay() {
        suffixOrder(0);
    }

    public void prefixOrder(int index) {
        if((arr == null) || (arr.length == 0)) {
            System.out.println("当前数组为空");
        }
        System.out.println(arr[index]);
        if((index*2+1) < arr.length) {
            prefixOrder(index*2+1);
        }
        if((index*2+2) < arr.length) {
            prefixOrder(index*2+2);
        }
    }

    public void infixOrder(int index) {
        if((arr == null) || (arr.length == 0)) {
            System.out.println("当前数组为空");
        }
        if((index*2+1) < arr.length) {
            infixOrder(index*2+1);
        }
        System.out.println(arr[index]);
        if((index*2+2) < arr.length) {
            infixOrder(index*2+2);
        }
    }

    public void suffixOrder(int index) {
        if((arr == null) || (arr.length == 0)) {
            System.out.println("当前数组为空");
        }
        if((index*2+1) < arr.length) {
            suffixOrder(index*2+1);
        }
        if((index*2+2) < arr.length) {
            suffixOrder(index*2+2);
        }
        System.out.println(arr[index]);
    }
}
```

##### 三、线索二叉树

> 一般来说二叉树的空指针域约为n+1，如果利用这些空指针域来存放前驱和后继，我们就将其称为线索。一般分为三种线索，前序索引、中序索引、后序索引。
>
> left两种情况：左子树或者前驱节点。
>
> right两种情况：右子树或者后继节点。

``` java
public class ThreadedTree{
    private TreeNode root;
    private TreeNode pre;


    public ThreadedTree(TreeNode root) {
        this.root = root;
        threadedTreeSuffix(root);
    }

    /**
     * 中序索引
     * @param treeNode
     */
    public void threadedTreeInfix(TreeNode treeNode) {
        // node
        if(treeNode == null) {
            return;
        }

        // 线索化左子树
        threadedTreeInfix(treeNode.getLeft());

        // 线索化当前节点
        if(treeNode.getLeft() == null) {
            treeNode.setLeft(pre);
            treeNode.setLeftType(1);
        }

        if(pre != null && pre.getRight() == null) {
            pre.setRight(treeNode);
            pre.setRightType(1);
        }

        pre = treeNode;
        // 线索化右子树
        threadedTreeInfix(treeNode.getRight());
    }

    /**
     * 前序索引
     * @param treeNode
     */
    public void threadedTreePrefix(TreeNode treeNode) {
        // node
        if(treeNode == null) {
            return;
        }

        // 线索化当前节点
        if(treeNode.getLeft() == null) {
            treeNode.setLeft(pre);
            treeNode.setLeftType(1);
        }

        if(pre != null && pre.getRight() == null) {
            pre.setRight(treeNode);
            pre.setRightType(1);
        }

        pre = treeNode;

        // 线索化左子树
        threadedTreePrefix(treeNode.getLeft());
        // 线索化右子树
        threadedTreePrefix(treeNode.getRight());
    }

    /**
     * 后序索引
     * @param treeNode
     */
    public void threadedTreeSuffix(TreeNode treeNode) {
        // node
        if(treeNode == null) {
            return;
        }

        // 线索化左子树
        threadedTreeSuffix(treeNode.getLeft());
        // 线索化右子树
        threadedTreeSuffix(treeNode.getRight());

        // 线索化当前节点
        if(treeNode.getLeft() == null) {
            treeNode.setLeft(pre);
            treeNode.setLeftType(1);
        }

        if(pre != null && pre.getRight() == null) {
            pre.setRight(treeNode);
            pre.setRightType(1);
        }

        pre = treeNode;
    }

    /**
     * 中序索引遍历
     */
    public void displayInfix() {
        TreeNode temp = root;

        while(temp != null) {
            while(temp.getLeftType() == 0) {
                temp = temp.getLeft();
            }

            System.out.println(temp);

            while(temp.getRightType() == 1) {
                temp = temp.getRight();
                System.out.println(temp);
            }
            temp = temp.getRight();
        }
    }

    public static void main(String[] args) {
        TreeNode node1 = new TreeNode("小明", 1);
        TreeNode node2 = new TreeNode("小李", 2);
        TreeNode node3 = new TreeNode("小王", 3);
        TreeNode node4 = new TreeNode("小呆", 4);
        TreeNode node5 = new TreeNode("小强", 5);
        node1.setLeft(node2);
        node1.setRight(node3);
        node3.setRight(node4);
        node2.setRight(node5);

        ThreadedTree threadedTree = new ThreadedTree(node1);
//        System.out.println(node5.getRight());
        threadedTree.displaySuffix();
    }
}


@Getter
@Setter
class TreeNode {
    private String name;
    private TreeNode left;
    private TreeNode right;
    private int id;

    // 0表示左子树，1表示前驱节点
    private int leftType;
    // 0表示右子树，1表示后继节点
    private int rightType;

    public TreeNode(String name, int id) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "TreeNode{" +
                "name='" + name + '\'' +
                ", id=" + id +
                '}';
    }
}
```

##### 四、赫夫曼树(未完待续)

> 所有叶子节点的带权路径长度最小则称为霍夫曼树，即wpl最小。
>
> 移动原则：
>
> 1. 从小到大进行排序，将每个数据，每个数据都是一个节点，每个节点都可以看成一个最简单的二叉树。
> 2. 取出根节点权值最小的两颗二叉树
> 3. 组成新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点的权值的和。
> 4. 再将这颗新的二叉树，一根节点的权值大小再次排序，不断重复1-2-3-4的步骤，知道数列中所有数据被处理。

- 代码实现

  ``` java
  
  ```

- 赫夫曼编码

  > 利用了赫夫曼树对数据进行压缩和解压。

  ``` java
  
  ```

##### 五、二叉排序树

> 能够使得插入、删除和修改都比较快。使得左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。能够提高二分查找的效率，因为插入后直接就是有序的。

- 删除情况

  - 叶子节点

    > 找到节点和他的父节点，进而判断是左子节点还是右子节点。

  - 一颗子树

    > 找到节点和父节点，一般分为四种情况

  - 两颗子树

    > 找到节点和父节点，如果是替换为右子树的值就取得最小值，左子树的值就取最大值。

- 代码实现

  ``` java
  public class BinarySortTreeTest {
      public static void main(String[] args) {
          BinarySortTree of = BinarySortTree.of();
          int[] arr = {22, 33, 44, 55, 11};
          for (int i = 0; i < arr.length; i++) {
              of.add(TreeNode.of(arr[i]));
          }
  
          of.display();
          System.out.println("=================");
          of.delNode(55);
          of.delNode(11);
          of.delNode(33);
          of.delNode(55);
          of.display();
      }
  }
  
  class BinarySortTree {
      private TreeNode root;
  
      public static BinarySortTree of() {
          BinarySortTree binarySortTree = new BinarySortTree();
          return binarySortTree;
      }
      public void add(TreeNode treeNode) {
          if(root == null) {
              root = treeNode;
          }else {
              root.add(treeNode);
          }
      }
  
      public void display() {
          if(root == null) {
              System.out.println("树为空");
          }else {
              root.displayInfix();
          }
      }
  
      public TreeNode search(int value) {
          if(root == null) {
              return null;
          }else {
              return root.search(value);
          }
      }
  
      public TreeNode searchParent(int value) {
          if(root == null) {
              return null;
          }else {
              return root.searchParent(value);
          }
      }
  
      public int delTreeMin(TreeNode node) {
          TreeNode target = node;
          while(target.getLeft() != null) {
              target = target.getLeft();
          }
          delNode(target.getValue());
          return target.getValue();
      }
  
      public void delNode(int val) {
          if(root == null) {
              return;
          }else {
              TreeNode search = search(val);
              // 节点不存在
              if(search == null) {
                  return;
              }
  
              // 只有root一个节点
              if(root.getLeft() == null && root.getRight() == null) {
                  root = null;
                  return;
              }
  
              TreeNode treeNode = searchParent(val);
              if(search.getLeft() == null && search.getRight() == null) {
                  if(treeNode.getLeft()!=null
                          && treeNode.getLeft().getValue() == val) {
                      treeNode.setLeft(null);
                  } else if(treeNode.getRight()!=null
                          && treeNode.getRight().getValue() == val) {
                      treeNode.setRight(null);
                  }
              }else if(search.getLeft() != null && search.getRight() != null) {
                  int i = delTreeMin(search.getRight());
                  search.setValue(i);
              }else {
                  // 要删除的节点有左子节点
                  if(search.getLeft() != null) {
                      if(treeNode != null) {
                          if(treeNode.getLeft().getValue() == val) {
                              treeNode.setLeft(search.getLeft());
                          }else {
                              treeNode.setRight(search.getLeft());
                          }
                      }else {
                          root = search.getLeft();
                      }
                  }else { // 要删除的节点有右子节点
                      if(treeNode != null) {
                          if(treeNode.getRight().getValue() == val) {
                              treeNode.setRight(search.getRight());
                          }else {
                              treeNode.setLeft(search.getRight());
                          }
                      }else {
                          root = search.getRight();
                      }
                  }
              }
          }
      }
  }
  
  @Data
  class TreeNode {
      private TreeNode right;
      private TreeNode left;
  
      private int value;
  
      public static TreeNode of(int value) {
          TreeNode treeNode = new TreeNode();
          treeNode.value = value;
          return treeNode;
      }
  
      public void add(TreeNode treeNode) {
          if(treeNode == null) {
              return;
          }
  
          if(treeNode.value < this.value) {
              if(this.left == null) {
                  this.left = treeNode;
              }else {
                  this.left.add(treeNode);
              }
          }else {
              if(this.right == null) {
                  this.right = treeNode;
              }else {
                  this.right.add(treeNode);
              }
          }
      }
  
      /**
       * 查找子节点
       * @param value
       * @return
       */
      public TreeNode search(int value) {
          if(this.value == value) {
              return this;
          }else {
              if(this.value > value) {
                  if(this.left == null) {
                      return null;
                  }else {
                     return this.left.search(value);
                  }
              }else {
                  if(this.right == null) {
                      return null;
                  }else {
                      return this.right.search(value);
                  }
              }
          }
      }
  
      /**
       * 查找父节点
       * @param value
       * @return
       */
      public TreeNode searchParent(int value) {
          if((this.left != null && this.left.value == value) ||
          this.right != null && this.right.value == value) {
              return this;
          }else {
              if(value > this.value) {
                  return this.right.searchParent(value);
              }else if(value <= this.value) {
                  return this.left.searchParent(value);
              }else {
                  return null;
              }
          }
      }
  
      public void displayInfix() {
          if(this.left != null) {
              this.getLeft().displayInfix();
          }
  
          System.out.println(this.getValue());
  
          if(this.right != null) {
              this.getRight().displayInfix();
          }
      }
  }
  ```

##### 六、平衡二叉树

> 因为二叉排序树存在一种极端情况就是一个斜的链表，所以要通过平衡二叉来优化。它是一个空树，或者左右子树的高度差不超过1。

``` java
@Data
class TreeNode {
    private TreeNode right;
    private TreeNode left;

    private int value;

    /**
    * 左树高度
    */
    public int leftHeight() {
        if(left == null) {
            return 0;
        }else {
            return left.height();
        }
    }

    /**
    * 右树高度
    */
    public int rightHeight() {
        if(left == null) {
            return 0;
        }else {
            return right.height();
        }
    }

    /**
    * 左旋转
    */
    private void leftRotate() {
        // 创建新节点
        TreeNode newNode = of(value);
        // 新节点左子树为当前节点的左子树
        newNode.left = left;
        // 新节点的右子树为当前节点右子树的左子树
        newNode.right = right.left;
        // 当前节点的值为右子树的值
        value = right.value;
        // 当前节点的右子树为右子树的右子树
        right = right.right;
        // 当前节点的左子树为新的节点
        left = newNode;
    }

    /**
    * 右旋转
    */
    private void rightRotate() {
        // 创建新节点
        TreeNode newNode = of(value);
        // 新节点左子树为当前节点的左子树
        newNode.right = right;
        // 新节点的右子树为当前节点右子树的左子树
        newNode.left = left.right;
        // 当前节点的值为右子树的值
        value = left.value;
        // 当前节点的右子树为右子树的右子树
        left = left.left;
        // 当前节点的左子树为新的节点
        right = newNode;
    }

    public int height() {
        return Math.max(left == null ?0:left.height(), right==null?0:right.height())+1;
    }

    public static TreeNode of(int value) {
        TreeNode treeNode = new TreeNode();
        treeNode.value = value;
        return treeNode;
    }

    public void add(TreeNode treeNode) {
        if(treeNode == null) {
            return;
        }

        if(treeNode.value < this.value) {
            if(this.left == null) {
                this.left = treeNode;
            }else {
                this.left.add(treeNode);
            }
        }else {
            if(this.right == null) {
                this.right = treeNode;
            }else {
                this.right.add(treeNode);
            }
        }

        if(rightHeight() - leftHeight() > 1) {
            leftRotate();
            if(right != null && right.rightHeight() > right.leftHeight()) {
                right.leftRotate();
                leftRotate();
            }else {
                leftRotate();
            }
        }

        if(leftHeight() - rightHeight() > 1) {
            if(left != null && left.rightHeight() > left.leftHeight()) {
                left.leftRotate();
                rightRotate();
            }else {
                rightRotate();
            }
        }
    }

    public void displayInfix() {
        if(this.left != null) {
            this.getLeft().displayInfix();
        }

        System.out.println(this.getValue());

        if(this.right != null) {
            this.getRight().displayInfix();
        }
    }
}
```

##### 七、多路查找树

> 二叉树的缺点在于它的节点很多，构建起来麻烦，需要多次I/O操作，同时如果节点增多，高度也会很高。

###### 1. 2-3树

> 最简单的B树结构。

- 所有叶子节点都在同一层。
- 一个节点要么是二节点，要么是三节点，要么是叶子节点。

###### 2. B树

> B树通过重新组织节点，来降低了树的高度，一般会利用磁盘预读原理，一般为4k。将树的度M设置为1024，600亿个元素中最多只需要4次I/O就可以读取到想要的元素。

- 特点
  - B树的阶：节点的最多子节点的个数。
  - 从根节点开始，相当于每次进行一次二分
  - 数据分布在整棵树中

###### 3. B+树

- 特点
  - 数据仅出现在叶子节点。
  - 上层节点主要用于索引来对数据进行分段。
- mysql为什么使用B+树
  - 因为每次B树每个节点会存数据，所以io读写就会稍慢
  - 同时更加适合范围查询

###### 4. B*树

> 增加子树节点之间的索引。

### 图

- 基本概念

  - 图的组成

    > 是由节点和边组成的一种数据结构。

  - 加权图

    > 每个边都有相应的权重。

  - 应用
    - 编写国际跳棋AI，计算最少多少步能赢。
    - 计算最少编辑多少个地方就可以将错拼的单词改成正确的。
    - 根据你对人际关系网络找到最近的医生。
- 算法

    - 广度优先算法
      - 解决问题
        - a->b，有前往路径吗
        - a->b，什么路径最短
        
      - 实现思路
        - 先通过散列表的方式来记录每个节点的相邻节点。
        - 创建一个队列，用于存储要检查的人。
        - 如果是就大功告成，不是就将。
  - 还需要一个数组来检查是否检查过，防止循环依赖，即我是你的朋友，你又是我的朋友。
        
      - 实现
      
        ``` java
        
        ```
      
    - 迪克斯特拉算法：能够计算加权图的最短路径，只适用于有向无环图，而且也不适用于负权重(使用贝尔曼福德算法)
    
      - 步骤
    
        - 需要一张表来表示父节点的列来确认路径
        - 找出最便宜的界定啊，即可在最短时间内到达的节点
        - 更新该节点的邻居的开销
        - 重复这个过程，直到对图中的每个节点都这样做了
        - 计算最终路径
    
      - 实现
    
        ``` java
        
        ```

### 散列

#### 哈希表（最简单的实现）

``` java
// 基本类
@Data
public class Person {
    private int id;
    private String name;
    private Person next;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public Person() {
    }
}

// 链表
public class PersonList {
    private Person head = new Person();

    public void add(Person person) {
        Person temp = head;
        while(temp.getNext()!=null) {
            temp = temp.getNext();
        }
        temp.setNext(person);
    }

    public Person findById(int id) {
        if(head.getNext() == null) {
            throw new RuntimeException("链表为空");
        }
        Person temp = head;
        while(temp.getNext() != null) {
            if(temp.getNext().getId() == id) {
                return temp.getNext();
            }
            temp = temp.getNext();
        }
        return null;
    }

    public void show() {
        if(head.getNext() == null) {
            System.out.println("链表为空");
        }
        Person temp = head;
        while(temp.getNext() != null) {
            System.out.print(temp.getNext().getName()+" ");
            temp = temp.getNext();
        }
        System.out.println();
    }
}

// 哈希表
public class HashMapTest {
    // 数组长度
    private int size;

    public static void main(String[] args) {
        HashMapTest hashMapTest = new HashMapTest(3);
        hashMapTest.add(new Person(1, "小明"));
        hashMapTest.add(new Person(2, "小红"));
        hashMapTest.add(new Person(3, "小蓝"));
        hashMapTest.add(new Person(4, "小绿"));

        hashMapTest.show();
        System.out.println(hashMapTest.findById(5));
    }

    // 链表数组
    private PersonList[] listArr;

    // 初始化哈希表
    public HashMapTest(int size) {
        this.size = size;
       listArr = new PersonList[size];
       // 初始化每个链表
        for (int i = 0; i < listArr.length; i++) {
            listArr[i] = new PersonList();
        }
    }

    public Person findById(int id) {
        return listArr[hashCode(id)].findById(id);
    }

    // 添加元素
    public void add(Person person) {
        listArr[hashCode(person.getId())].add(person);
    }

    public void show() {
        for (int i = 0; i < listArr.length; i++) {
            listArr[i].show();
        }
    }

    // 计算hash值
    public int hashCode(int id) {
        return id%size;
    }
}
```

- 应用
  - 用作缓存：先查看缓存，如果缓存有就直接返回。
- 解决hash冲突的方法
  - 开放寻址：通过运算放在另一个位置
  - 链地址法
  - 再散列

# 常见算法

## 查找

### 一、普通查找

> 依次遍历所有元素，找到就返回下标，没有找到返回-1。

```java
public int find(int[] arr, int target) {    
    int index = -1;    
    for(int i=0;i<arr.length;i++) {        
        if(arr[i]==index) {            
            index = i;            
            break;        
        }    
    }    
    return index;
}
```

### 二、二分查找

> 存在的主要问题就是，如果是位于边上的值时，查找的速度会偏慢，需要很多次才能找到相应的值。公式为：mid=low+(high-low)/2

- 递归

  ```java
  // 默认都是有序数组，时间复杂度logn
  public int find(int[] arr, int target, int start, int end) {    
      if(start > end || target>arr[end] || target<arr[start]) {            
          return -1;    
      }    
      int mid = (start+end)/2;    
      if(arr[mid] == target) {        
          return mid;    
      }else {        
          if(target > arr[mid]) {            
              start = mid+1;        
          }else if(target < arr[mid]) {            
              end = mid-1;        
          }    
      }    
      return find(arr, target, start, end);
  }
  ```

- 非递归

  ```java
  public int find(int[] arr, int target) {    
      int start = 0;    
      int end = arr.length - 1;    
      int mid = (start+end) / 2;    
      while(true) {        
          if(start > end) {            
              return -1;        
          }                
          if(arr[mid] == target) {            
              return mid;        
          }else {            
              if(arr[mid] > target) {                
                  end = mid - 1;            
              }else if(arr[mid] < target) {                
                  start = mid + 1;            
              }        
          }        
          mid = (start+end)/2;    
      }
  }
  ```

### 三、插值查找

> 对数据量比较大，分布比较均匀的，查找速度比较快。mid=low+(key-a[low])/(a[high]-a[low])(high-low)

``` java
public static int findInsert(int[] arr, int left, int right, int val) {
    Arrays.sort(arr);
    if (val > arr[arr.length-1] || val < arr[0] || left > right) {
        return -1;
    }

    // 通过该公式计算得出中间值
    int mid = left + (right - left) * (val - arr[left]) / (arr[right] - arr[left]);
    if (arr[mid] == val) {
        return mid;
    }else {
        if(arr[mid] > val) {
            return findInsert(arr, left, mid-1, val);
        }else {
            return findInsert(arr, mid+1, right, val);
        }
    }
}
```

### 四、斐波那契查找

> 也叫黄金分割查找，基于公式mid=low+F(k-1)-1，通过扩充数组每次找到黄金分割点进行取值。
>
> 推导:
>
> f(k)=f(k-1)+f(k-2)，f(k)-1=(f(k-1)-1)+(f(k-2)-1)+1，把f(k)-1看成整个数组就分为三部分，f(k-1)-1、1、f(k-2)-1。

``` java
/**
     * 获得一个斐波那契数列
     * @return
     */
public static int[] getFib(int size) {
    int[] f= new int[size];
    f[0] = 1;
    f[1] = 1;
    for (int i = 2; i < f.length; i++) {
        f[i] = f[i-1]+f[i-2];
    }
    return f;
}

public static int findFib(int[] arr, int val) {
    int low = 0;
    int high = arr.length - 1;
    int k = 0;
    int mid = 0;
    int[] f = getFib(100);
    // 获取斐波那契下标
    while(high > f[k] - 1) {
        k++;
    }
    // 扩充数组
    int[] temp = Arrays.copyOf(arr, f[k]);
    for (int i = high+1; i < temp.length; i++) {
        temp[i] = arr[high];
    }

    while(low <= high) {
        if (k > 0){
            mid = low+f[k-1]-1;
        }else {
            mid = low;
        }

        if(val < temp[mid]) {
            high = mid - 1;
            k--;
        }else if(val > temp[mid]) {
            low = mid + 1;
            k -= 2;
        }else {
            if(mid <= high) {
                return mid;
            }else {
                // 如果数组填充，则返回填充之前的最高位
                return high;
            }
        }
    }
    return -1;
}
```

## 排序算法

| 算法 | 平均时间 | 最差情形 | 稳定度          | 额外空间 | 备注 |
| ---- | -------- | -------- | --------------- | -------- | ---- |
| 冒泡 | O(n²)    |   O(n²)       | 稳定 | 1 | n小时较好 |
| 选择 | O(n²)         | O(n²) | 不稳定 | 1 | n小时较好 |
| 插入 | O(n²) | O(n²) | 稳定 | 1 | n小时较好 |
| 基数 | d(n+k)  | d(n+k) | 稳定 | n+k | 和数据规模和桶个数有关 |
| 希尔 | nlogn    | n~n² | 不稳定 | 1 | $是所选分组 |
| 快速 | nlogn    | n² | 不稳定 | nlogn | n大时较好 |
| 归并 | nlogn    | nlogn | 稳定 | 1 | n大时较好 |
| 堆 | nlogn    | nlogn | 不稳定 | 1 | n大时较好 |

> 注：稳不稳定指相同的数如果之前在前面，排序后还在前面。

### 一、交换排序

#### 1. 冒泡排序

> 比较的数组依次变小，如果后一个元素比前一个元素大则交换位置，直到剩余数组没有需要交换位置为止。

``` java
public static void bubbleSort(int[] arr) {
    int temp = 0;
    boolean flag = false;
    for (int i = arr.length-1; i >= 1; i--) {
        flag = false;
        for (int j = 0; j < i; j++) {
            if(arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                flag = true;
            }
        }
        if(!flag) {
            break;
        }
    }
}
```

#### 2. 快速排序

> 取左边的数为基准值，然后比较右边的，直到有小于基准值的进行交换，然后是左边出现大的时交换，最后左右指针重合，交换基准值和指针的位置，然后左右循环迭代。

``` java
public static void quickSort(int[] arr, int left, int right) {
    if(left >= right) {
        return;
    }
    int l = left;
    int r = right;
    int base = arr[l];
    while(l < r) {
        while(arr[r] >= base && l<r) {
            -- r;
        }
        arr[l] = arr[r];

        while(arr[l] <= base && l<r) {
            ++ l;
        }
        arr[r] = arr[l];
    }

    arr[l] = base;
    quickSort(arr, left, l-1);
    quickSort(arr, l+1, right);
}
```

- 存在的问题

  > 什么时候变为 n^2：如果是一个有序数组每次选头最为基准值就会退化为n^2，所以就需要随机选择基准值。


### 二、插入排序

#### 1. 直接插入

> 基本思路是将数组分为排序和未排序的两部分，每次去出未排序的第一个元素和已排序的比较，如果位置发生改变，则在插入位置赋值，同时要把元素依次后移。

``` java
public static void insertSort(int[] arr) {
    int insertValue;
    int insertIndex;
    for (int i = 1; i < arr.length; i++) {
        insertValue = arr[i];
        for (insertIndex = i-1; insertIndex >= 0 && insertValue < arr[insertIndex]; insertIndex --) {
            arr[insertIndex+1]= arr[insertIndex];
        }
        if(insertIndex+1 != i) {
            arr[insertIndex+1] = insertValue;
        }
    }
}
```

#### 2. 希尔排序(对直接插入进行了优化)

> 插入排序的问题是如果数小的话，要插入到前面移动的次数就会很多，针对这个问题，希尔排序进行了优化，基本思路是先去不同的步长进行分组，然后采用插入排序的方法进行宏观上的前后顺序的调整，最后再进行依次插入的时候能够减少移动的距离。

``` java
// 通过交换的方式进行希尔排序，效率较低
public static void shellSort1(int[] arr) {
    for (int i = arr.length/2; i >= 1 ; i/=2) {
        for (int j = i; j < arr.length; j++) {
            for (int k = j - i; k >= 0; k-=i) {
                if(arr[k] > arr[k+i]) {
                    int temp = arr[k];
                    arr[k]= arr[k+i];
                    arr[k+i] = temp;
                }
            }
        }
    }
}

// 通过移动位置进行希尔排序，效率很高
public static void shellSort2(int[] arr) {
    for (int i = arr.length/2; i >= 1 ; i/=2) {
        for (int j = i; j < arr.length; j++) {
            int temp = arr[j];
            int index = j;
            if(arr[index - i] > temp) {
                while(index-i >= 0 && temp < arr[index-i]) {
                    arr[index] = arr[index - i];
                    index -= i;
                }
                arr[index] = temp;
            }
        }
    }
}
```

### 三、选择排序

#### 1. 简单选择

> 和冒泡不同的是，每次选出最小的放在前面或最大放后面，不用频繁的交换元素，直到最后一个元素为止。

``` java
public static void selectSort(int[] arr) {
    int minIndex;
    for (int i = 0; i < arr.length-1; i++) {
        minIndex = i;
        for (int j = i; j < arr.length; j++) {
            if(arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if(minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
```

### 四、堆排序

- 基本概念
  - 大顶堆：每个节点的值大于或等于孩子节点的值。
  - 小顶堆：每个节点的值小于或等于孩子节点的值。

``` java
public class HeapSortTest {
    public static void main(String[] args) {
        int[] arr = {22, 11, 9, 44, 33};

        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void heapSort(int[] arr) {
        for (int i = arr.length / 2 - 1; i >= 0 ; i--) {
            adjustHeap(arr, i, arr.length);
        }

        int temp;
        for (int i = arr.length -1; i > 0 ; i--) {
            temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            adjustHeap(arr, 0, i);
        }
    }

    /**
     *
     * @param arr 数组
     * @param i 索引
     * @param length 对多少个元素进行调整
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        // 先取出元素的值
        int temp = arr[i];

        // 不断取得左子节点的值
        for (int j = 2*i+1; j < length; j = 2*j+1) {
            // 左子节点的值小于右子节点的值
            if(j+1 < length && arr[j] < arr[j+1]) {
                j++;
            }

            if(arr[j] > temp) {
               arr[i] = arr[j];
               i = j;
            }else {
                break;
            }
        }

        arr[i] = temp;
    }
}
```

### 五、归并排序

> 利用分治的思想，先不断递归将其分到最小，然后开始合并从小到大，需要引入一个临时数组，直到全部排序成功。

``` java
public static void mergeSort(int[] arr, int left, int right, int[] temp) {
    if(left < right) {
        int mid = (left+right)/2;
        mergeSort(arr, left, mid, temp);
        mergeSort(arr, mid+1, right, temp);
        merge(arr, left, mid, right, temp);
    }
}

public static void merge(int[] arr, int start, int mid, int end, int[] temp) {
    int i = start;
    int j = mid + 1;
    int t = 0;
    while(i <= mid && j <= end) {
        if(arr[i] >= arr[j]) {
            temp[t] = arr[j];
            j++;
            t++;
        }else {
            temp[t] = arr[i];
            i++;
            t++;
        }
    }

    while(i <= mid) {
        temp[t] = arr[i];
        i ++;
        t ++;
    }

    while(j <= end) {
        temp[t] = arr[j];
        j ++;
        t ++;
    }
    
    System.arraycopy(temp, 0, arr, start, end - start+1);
}
```

### 六、基数排序

``` java
// 负数时可以用其他排序
public static void radixSort(int[] arr) {
    // 开辟桶空间
    int[][] bucket = new int[10][arr.length];

    // 记录每个桶元素的个数
    int[] bucketCounts = new int[10];

    // 求最大数
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if(arr[i] > max) {
            max = arr[i];
        }
    }

    // 得到它的位数
    int maxLength = (""+max).length();

    // 放入桶内
    for (int i = 0, n=1; i < maxLength; i++, n *= 10) {
        for (int j = 0; j < arr.length; j++) {
            int digit = arr[j]/n%10;
            bucket[digit][bucketCounts[digit]] = arr[j];
            bucketCounts[digit]++;
        }

        int index = 0;
        // 取出桶中元素
        for (int k = 0; k < bucketCounts.length; k++) {
            if(bucketCounts[k] != 0) {
                for (int l= 0; l < bucketCounts[k]; l++) {
                    arr[index++] = bucket[k][l];
                }
            }
            bucketCounts[k] = 0;
        }
    }
}
```

### 七、外部排序

> 主要涉及到大数据相关，不能考内存就直接处理，需要内存和外存相互结合。

## 其他算法

### 一、洗牌算法

``` java
public static void shuffle(int[] arr) {
    Random random = new Random();
    for (int i = arr.length-1; i >= 1; --i) {
        int temp = random.nextInt(i+1);
        swap(arr, temp, i);
    }
}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### 二、查找回文数

``` java
public class Demo {
    public static void main(String[] args) {
        Integer[] s = getS(11, 20000);
        System.out.println(Arrays.toString(s));
    }

    public static Integer[] getS(int start, int end) {
        if(start > end) {
            return new Integer[0];
        }
        ArrayList<Integer> list = new ArrayList<>();
        int d = 0;
        int b = 0;
        int c = 0;
        for (int i = start; i <= end ; i++) {
            d = i;
            b = 0;
            while(d!=0) {
                c = d%10;
                b = b*10+c;
                d/=10;
            }
            if(b==i) {
                list.add(i);
            }
        }
        return list.toArray(new Integer[list.size()]);
    }
}
```

### 三、反向索引

> 通过对应的hash找到对应的页面。

### 四、傅里叶变换

> 能将东西分解，告诉你它包含哪些成分。可以进行音频压缩以及音频识别。

### 五、并行算法

> 主要是更充分的利用多核环境，但也会存在很多限制因素，加入有1000个元素，如何分配任务，并且如何进行合并都需要开销，而且如何均匀的分配任务，让两核执行的时间基本一致也需要研究。

### 六、mapreduce

> mapreduce是一种流行的分布式算法，对于处理大数据十分有用，是基于映射和归并的思想来实现的。

- 映射函数：通过map自动将其分配给对应的计算机。
- 归并函数：将其合并为一个元素。

### 七、布隆过滤器和HyerLogLog

- 布隆过滤器

  > 是一种数据结构，主要用于大数据进行过滤，一般不要求结果绝对准确时使用。

- HyerLogLog

  > 近似的计算包含在集合中的元素数。

### 八、SHA算法

> 是一种摘要算法，可以比较大文件是否存在，同时还会用在密码校验中。

- 局部敏感：simhash
  - google使用simhash来判断网页是否已经搜集
  - 老师通过simhash来判断学生的论文是否是抄的
  - scribd允许用户上传文档和图片，以便与人分享，但不希望用户上传有版权的内容。这个网站可使用simhash来检查是否于小说类似

### 九、密钥交换Diffie-Hellman

> 是rsad的一个前伸

### 十、线性规划

> 所有图算法都可以使用线性规划来实现，线性规划是一个宽泛的多的框架，图问题只是其中的一个子集而已。线性规划使用Simplex算法。

## 分治算法

## 贪婪算法

> 可以近似的得到一个最优解。

- 课程问题
  - 先找出结束最早的课
  - 选择结束才开始的课，同时选择最早的课
  
- np问题

  > 对于这类问题，没有找到快速解决方案，最佳的方案是使用近似算法。

  - 集合覆盖问题

    > 如果使用普通方法会出现很大，计算非常多。

    - 通常解法
      - 列出每个可能的广播台集合，被称为幂集，可能有2^n个
      - 在这些集合中，选出覆盖全美50个州的最小集合
    - 使用贪婪算法

  - 旅行商问题

## 动态规划

> 将大问题划分为小问题进行解决，从而一步步获得最优解的处理算法，下一个子阶段的解是建立再上一步的求解。

- 背包问题

  ``` java
  
  ```

- 字符串匹配问题

  ``` java
  
  ```

## k最近邻算法

- KNN算法

  > 根据特征点建立坐标，之后通过毕达哥拉斯公式来进行计算，进而计算出更加相似的两个坐标点。用于分类和回归，分类是编组，回归是预测结果。

  - netflix根据用户的评分来进行计算，进而进行推荐
  - 对于评分，假如指定一些意见领袖，他们的比重更加重要，如何实现

- 机器学习

  - OCR是光学字符识别
    - 第一步主要用来提取特征点，这个是需要进行训练的。
  - 朴素贝叶斯用来计算是垃圾文件的概率，进而判断垃圾文件。

## 斐波那契

- 递归

  ```java
  // 得到第n个数
  public int sum(int number) {    
  	if(number == 1 || number == 2) {        
          return 1;    
      }    
      return sum(number-1)+sum(number-2);
  }
  ```
  
- 非递归

  ```java
  // 得到第n个数
  private static int getNum1(int num) {
      int num1 = 1;
      int num2 = 1;
      if(num == 1) {
          return num1;
      }
      if(num == 2) {
          return num2;
      }
      for (int i = 3; i < num; i++) {
          int temp = num1;
          num1 = num2;
          num2 = temp+num2;
      }
      return num1+num2;
  }
  ```

## 计算机缓存

### 1. FIFO

> 添加时依此添加到链表末尾，缓存满时有先去除开头的第一个

```python
from day02.linkedlist 
import DoubleLinkedListfrom day02.linkedlist 
import Node
class FIFOCache:    
    def __init__(self, capacity=0xffff):        
        self.capacity = capacity        
        self.size = 0        
        self.list = DoubleLinkedList(self.capacity)    
        def put(self, value):        
            if self.capacity == 0:            
                return        
            node = self.list.ifExist(value)        
            if node:            
                self.list.remove(node)            
                self.list.append(node)        
                else:            
                    if self.size == self.capacity:                
                        self.list.pop()                						  							self.list.append(Node(value))            
                    else:                
                        self.list.append(Node(value))                
                        self.size += 1    
                        
                        
     def print(self):        
        self.list.print()
        
        
if __name__ == "__main__":    
    fifo_cache = FIFOCache(3)    
    fifo_cache.put(3)    
    fifo_cache.put(4)    
    fifo_cache.put(5)    
    fifo_cache.print()    
    fifo_cache.put(3)    
    fifo_cache.print()    
    fifo_cache.put(7)    
    fifo_cache.print()    
    print(fifo_cache.size)    
    print(fifo_cache.capacity)
```

### 2. LRU

> 添加时添加到头部，满时去除末尾的

```python
from day02.linkedlist 
import DoubleLinkedListfrom day02.linkedlist 
import Node
class FIFOCache:    
    def __init__(self, capacity=0xffff):        
        self.capacity = capacity        
        self.size = 0        
        self.list = DoubleLinkedList(self.capacity)    

    def put(self, value):        
        if self.capacity == 0:            
            return            
        if self.list.ifExist(value):            
            return        
        else:            
            if self.size == self.capacity:                
                self.list.remove()                												self.list.append_head(Node(value))            
            else:                
                self.list.append_head(Node(value))                
                self.size += 1    
                    
                    
     def print(self):        
        self.list.print()
        
if __name__ == "__main__":    
    fifo_cache = FIFOCache(3)    
    fifo_cache.put(3)    
    fifo_cache.put(4)    
    fifo_cache.put(5)    
    fifo_cache.print()    
    fifo_cache.put(7)    
    fifo_cache.print()    
    print(fifo_cache.size)    
    print(fifo_cache.capacity)
```

## 递归

> 就是方法自己调用自己，可以帮助编程者解决复杂问题，同时也能够使代码更加简洁。递归需要两个条件，一个是结束条件，一个是传递表达式(基线)。递归主要就是利用了栈调用。

## 一、求和

``` java
public static int sum(int[] arr, int n) {
    if(n == 0) {
        return 0;
    }
    return arr[n-1]+sum(arr,n-1);
}
```

### 二、阶乘

``` java
public static int factorial(int num) {
    if(num == 1) {
        return 1;
    }
    return factorial(num-1)*num;
}
```

### 二、汉诺塔

``` java

```

### 三、八皇后

``` java

```

### 四、迷宫

> 迷宫问题是通过递归来判断，可以通过遍历所有的策略来判断最短路径问题。
>

``` java
public class MapTest {
    public static void main(String[] args) {
        // 初始化地图
        int[][] map = new int[8][7];
        for (int i = 0; i < map[0].length; i++) {
            map[0][i] = 1;
            map[map.length - 1][i] = 1;
        }
        for (int i = 0; i < map.length; i++) {
            map[i][0] = 1;
            map[i][map[0].length - 1] = 1;
        }

        map[3][1] = 1;
        map[3][2] = 1;
        map[1][2] = 1;
        map[2][2] = 1;

        setWay(map, 1, 1);
        display(map);
    }

    public static void display(int[][] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
    }

    /**
     * 迷宫递归判断
     * @param map
     * @param i
     * @param j
     * @return
     */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) {
            return true;
        } else {
            if (map[i][j] == 0) {
                map[i][j] = 2;
                if (setWay(map, i + 1, j)) {
                    return true;
                } else if(setWay(map, i, j+1)) {
                    return true;
                } else if(setWay(map, i-1, j)) {
                    return true;
                } else if(setWay(map, i, j-1)) {
                    return true;
                } else {
                    map[i][j] = 3;
                    return false;
                }
            }else {
                return false;
            }
        }
    }
}
```

### 五、球和篮子

``` java

```